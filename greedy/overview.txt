=begin

Activity Selection: Select the maximum number of non-overlapping activities or intervals;

Huffman Coding: Create an optimal prefix code based on character frequencies for data compression;

Kruskal's Algorithm: Find the minimum spanning tree by greedily choosing the smallest-weight edges;

Prim's Algorithm: Build a minimum spanning tree by growing it one node at a time using the lowest-weight edge;

Dijkstra’s Algorithm: Find the shortest path from a source to all vertices in a graph with non-negative weights;

Fractional Knapsack: Maximize total value by taking fractional amounts of items, sorted by value-to-weight ratio;

Job Sequencing with Deadlines: Schedule jobs with deadlines to maximize profit while meeting constraints;

Egyptian Fraction: Represent a fraction as a sum of distinct unit fractions (like 1/2 + 1/3 + 1/16);

Interval Partitioning: Assign overlapping intervals to the fewest number of resources (e.g., classrooms);

Greedy Coloring (for graphs): Color the vertices of a graph so that no adjacent vertices share a color, using fewest colors possible;

Cashier’s Change Problem: Minimize the number of coins/notes given for a certain amount of change (works well with canonical coin systems);



==========

Greedy algorithms work when the greedy choice property and optimal substructure conditions hold — meaning making a local optimum at each step leads to a global optimum.

In problems like 0/1 Knapsack, greedy doesn’t work and you need dynamic programming instead.

=end